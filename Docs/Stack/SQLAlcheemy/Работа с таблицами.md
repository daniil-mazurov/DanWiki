>[!important] imports
>```python
>from sqlalchemy import Table, Column, Integer, String, MetaData
>from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship, joinedload, selectinload
>```

**Объявление таблицы происходит через запись в метаданные:**
- Императивный стиль (Core): ^f50dcc
```python
metadata_obj = MetaData()
"""Метаданные о создаваемых таблицах"""


my_table = Table(
	"tablename",
	metadata_obj,
	Column("id", Integer, primary_key=True),
	Column("first_col", String),
)
```
- Декларативный стиль (ORM): ^3677ec
```python
class Base(DeclarativeBase):
	'''Хранилище метаданных'''
	pass

class ExampleTable(Base):
	__tablename__ = "tablename"
	
	id: Mapped[int] = mapped_column(primary_key=True)
	first_col: Mapped[str]
```
#### metadata_obj.create_all(engine)
	Создание (CREATE TABLE) всех объявленных в метаданных таблиц
- engine - [[Подключение к БД#^b25557]]
#### metadata_obj.drop_all(engine)
	 Удаление(DROP TABLE) всех объявленных в метаданных таблиц
- engine -  [[Подключение к БД#^b25557]]

>[!info]
>В декларативном стиле доступ к метаданным можно получить через `Base.metadata`
#### Mapped
- Описание структур данных для создаваемых структур и объектов в базе
##### mapped_column()
- Инструмент для задания параметров объектам данных Mapped
## Relationship
Проектируя таблицу (модель данных) ей можно задать параметр `relationship`, обозначающий неявно один из типов связи таблиц (один к одному, один ко многим, многие ко многим). 
```python
class ExampleTable1(Base):
	extern_conn: Mapped[list["ExampleTable2"]] = relationship(back_populates="worker") # Связь один ко многим

class ExampleTable2(Base):
	worker_id: Mapped[int | None] = mapped_column(
		ForeignKey("tablename.id", ondelete="CASCADE")
	)

	worker: Mapped["ExampleTable1"] = relationship(back_populates="extern_conn") # Связь Многие к одному
```
`relationship` позволяет применять инструменты `joinedload` и `selectinload`. Они позволяют выполнить операцию JOIN в относительно простой форме.
### joinedload
Применяется в случае связей _**Многие к одному**_ и _**Один к одному**_.
Формирует конечную **квадратную** таблицу (что может вызывать дублирование информации, в случае если повторения значений внешнего ключа)
```python
query = select(ExampleTable).options(joinedload(ExampleTable.extern_conn))
result = session.execute(query)
result = result.unique().scalars().all() # ОБЯЗАТЕЛЬНО
```
### selectinload
Применяется в случае связей _**Многие ко многим**_ и _**Один ко многим**_.
Формирует конечное **дерево** зависимостей данных, где одной сущности таблицы может соответствовать множество сущностей другой таблицы (что однако не позволяет представить его как таблицу).
```python
query = select(ExampleTable).options(selectinload(ExampleTable.extern_conn))
result = session.execute(query)
result = result.unique().scalars().all() # ОБЯЗАТЕЛЬНО
```
# Типы данных
>[!important] imports
>```python
>import enum
>from typing import Annotated
>from datetime import datetime
>
>from sqlalchemy import Table, Column, Integer, String, MetaData, Enum, DateTime, ForeignKey, func, text, 
>from sqlalchemy.orm import Mapped, mapped_column
>```
## Первичный ключ
- Императивный стиль (Core):
```python
Column("id", Integer, primary_key=True)
```

- Декларативный стиль (ORM):
```python
id: Mapped[int] = mapped_column(primary_key=True)
```
## string, integer ...
- Императивный стиль (Core):
```python
Column("first_col", String(50), nullable=False)
# Поле nullable по умолчанию имеет значение True
```

- Декларативный стиль (ORM):
```python
first_col: Mapped[str | None] = mapped_column(String(50))
# str | None Напротив добавляет параметру возможность быть нулевым
```

>[!info]
>`String(50)` означает строковый тип данных с ограничением по количеству символов равным 50

## enum
- Императивный стиль (Core):
```python
Column(
	"enum_val",
	Enum(_ExampleEnum, values_callable=lambda obj: [e.value for e in obj]),
)
```

- Декларативный стиль (ORM):
```python
enum_val: Mapped[_ExampleEnum] = mapped_column(
	Enum(_ExampleEnum, values_callable=lambda obj: [e.value for e in obj])
)
```

`values_callable=lambda obj: [e.value for e in obj]` - Позволяет ввести в базу значения атрибутов, а не их имена

>[!info]- `_ExampleEnum` - класс для создания **Enum**
>```python
>class _ExampleEnumDecl(enum.Enum):
>	first_var = "1"
>	second_var = "2"
>```
## time
- Императивный стиль (Core):
```python
Column("date_val", DateTime, server_default=func.now())
```

- Декларативный стиль (ORM):
```python
date_val: Mapped[datetime] = mapped_column(server_default=func.now())
```
### server_default, default
Параметр типов данных задающий значение по умолчанию параметрам
- server_default - Значение по умолчанию получает база данных в результате выполнения команды.
	Например:
	- _server_default_ = **func.now()** - команда `now()` на языке SQL
	- _server_default_ = **text("TIMEZONE('utc',now())")** - аналог `now()`, но время по Гринвичу
- default - Значение по умолчанию получает интерпретатор Python, выполняя соответствующую функцию (либо передавая статичное значение)
	- _default_ = datetime.now
	- _default_ = 1
## Внешние ключи
- Императивный стиль (Core):
```python
Column(
	"foreign_val", Integer, ForeignKey("tablename.id", ondelete="CASCADE"),
)
```

- Декларативный стиль (ORM):
```python
foreign_val: Mapped[int | None] = mapped_column(
	ForeignKey("tablename.id", ondelete="CASCADE"),
)
```

-  Параметр `ondelete` задает поведение при удалении значения, на которое ссылается ключ, например:
	- `CASCADE` - каскадное удаление всех строк, имеющих этот внешний ключ
	- `SET NULL` - обнуление ключа
- `tablename.id` - название таблицы и параметр, на который ссылается ключ
## Кастомные типы
Кастомные (пользовательские) типы данных позволяют жестко задать параметры типам данных
```python
intpk = Annotated[int, mapped_column(primary_key=True)]
str_256 = Annotated[str, 256]


class ExampleTypes(Base):
__tablename__ = "types_examples"
	
	id: Mapped[intpk]
	maybe_none_val: Mapped[str_256 | None]
```
### Карта типов
В `Base` классе можно создать карту типов, жестко задав некоторые настройки без необходимости дублирования кода.

Файл settings.py
```python
intpk = Annotated[int, mapped_column(primary_key=True)]
str_256 = Annotated[str, 256]
```
Файл database.py
```python
class Base(DeclarativeBase):
	type_annotation_map = {
		str_256: String(256),
	}
```
Файл models.py
```python
class TestTable(Base):
	__tablename__ = "testtable"
	
	id: Mapped[intpk]
	title: Mapped[str_256]
```