В асинхронной модели несколько задач могут выполняться одновременно. Когда вызывается длительно выполняющаяся функция, она не блокирует поток выполнения программы. Вместо этого программа продолжает выполняться, а функция выполняется в фоновом режиме. Когда функция завершается, программа получает уведомление и может получить доступ к результату.
[[asyncio]]

```python
import asyncio  
  
async def download_file(url):  
	"""Download a file from a URL."""  
	with open(url, "wb") as f:  
		response = await asyncio.get(url)  
		f.write(response.content)  
  
async def main():  
	"""Download two files concurrently."""  
	tasks = [download_file("https://www.example.com/file1.txt"),  
	download_file("https://www.example.com/file2.txt")]  
	await asyncio.gather(*tasks)  
  
if __name__ == "__main__":  
	asyncio.run(main())
```
> [!important]
> Важно отметить, что asyncio оптимален **именно для I/O-bound задач** (сеть, файловые операции и т. д.), и **не подходит для CPU-bound операций** (вычислительно-интенсивных задач), поскольку в этом случае он не сможет переключаться на другие задачи во время блокировки. Для такого рода задач лучше использовать многопоточность или многопроцессорность. 
> Асинхронный ввод-вывод работает, когда у вас есть несколько задач, связанных с вводом-выводом, где в противном случае преобладали бы задачи, блокирующие время ожидания, связанное с вводом-выводом, например:
> - Сетевой ввод-вывод, независимо от того, является ли ваша программа серверной или клиентской
> - Бессерверные проекты, такие как одноранговая многопользовательская сеть, например, групповой чат
> - Операции чтения / записи, при которых вы хотите имитировать стиль “запустить и забыть”, но при этом меньше беспокоиться о блокировке всего, что вы читаете и записываете

> [!info]- CPU-bound и IO-Bound операции
> CPU-Bound операции нагружают вычислительные мощности текущего устройства, а IO-Bound позволяют выполнить задачу вне текущей железки.
> Разница важна тем, что число одновременных операций зависит от того, к какой категории они относятся. Вполне нормально запустить параллельно сотни IO-Bound операций, и надеяться, что хватит ресурсов обработать все результаты. Запускать же параллельно слишком большое число CPU-bound операций (больше, чем число вычислительных устройств) бессмысленно.
> ---
> Самым простым и эффективным способом решения CPU-Intensive задачи, заключается в использовании идиомы Fork-Join: задачу (например, входные данные) нужно разбить на определенное число подзадач, которые можно выполнить параллельно. Каждая подзадача должна быть независимой и не обращаться к разделяемым переменным/памяти. Затем, нужно собрать промежуточные результаты и объединить их.

Многопоточность - это способ одновременного выполнения нескольких задач в рамках одного процесса. Это достигается путем создания нескольких потоков, каждый из которых выполняет свой собственный код.
```python
import threading  
  
def do_something_threaded():  
	"""Do something that takes a long time."""  
	time.sleep(1)  
	print("Done!")  
  
def main():  
	"""Start two threads."""  
	threads = []  
	for _ in range(2):  
		thread = threading.Thread(target=do_something_threaded)  
		threads.append(thread)  
	for thread in threads:  
		thread.start()  
	for thread in threads:  
		thread.join()  
  
if __name__ == "__main__":  
	main()
```
Многопроцессорность - это способ одновременного выполнения нескольких задач в отдельных процессах. Это достигается путем создания нескольких процессов, каждый из которых выполняет свой собственный код в своем собственном пространстве памяти.
```python
import multiprocessing  
  
def do_something_multiprocessed():  
	"""Do something that takes a long time."""  
	time.sleep(1)  
	print("Done!")  
  
def main():  
	"""Start two processes."""  
	processes = []  
	for _ in range(2):  
		process = multiprocessing.Process(target=do_something_multiprocessed)  
		processes.append(process)  
	for process in processes:  
		process.start()  
```
![[Python_async_threading_multi.jpg]]
![[1_AYX4HrL47oD441FtPDG68A.webp]]